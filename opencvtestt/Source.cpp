/**
* @file bg_sub.cpp
* @brief Background subtraction tutorial sample code
* @author Domenico D. Bloisi
*/



/*
Reading from file:
example:
1
4 ,car , left: 173 , right: 229 , top: 195 , bot: 233, centerX:xx , centerY: xx ,car , left: 79 , right: 181 , top: 188 , bot: 239 ,car , left: 276 , right: 299 , top: 184 , bot: 209 ,car , left: 0 , right: 54 , top: 181 , bot: 241

first number - number of frames.
each line  - a single frame.
first number in each line - number of detections.
each detection has : name , left coordinate , right coordinate, top coordinate, bot coordinate.

*/
//opencv
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
//C
#include <stdio.h>
//C++
#include <fstream>
#include <iostream>
#include <sstream>

using namespace cv;
using namespace std;

// Global variables
//struct point {
//	int x;
//	int y;
//};

struct detection {
	char name[20];
	int left;
	int right;
	int top;
	int bot;
	cv::Point center;
	int id;
	bool clicked=false;
};

struct frameDetec {
	detection* detectionsInFrame;
	int numberOfDetection;
};

frameDetec* videoDetections;
Mat frame; //current frame
Mat smallImage;
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int keyboard; //input from keyboard
int detectionId = 0;		  //id of any detection.
int numberOfFrames;
string frameNumberString;
int intScore = 0;
int frameNumberInt;
char score[10] = "SCORE : ";
char imageName[4] = "car";
/** Function Headers */
void help();
void processVideo(char* videoFilename);
void processImages(char* firstFrameFilename);
void CallBackFunc(int event, int x, int y, int flags, void* userdata);
//void setTheCenterOfDetection();
void settingIDToAnyDetect();



//void setTheCenterOfDetection() {
//	for (int i = 0; i < numberOfFrames; i++) {
//		for (int j = 0; j < videoDetections[i].numberOfDetection; j++) {
//			videoDetections[i].detectionsInFrame[j].center.x = (videoDetections[i].detectionsInFrame[j].right - videoDetections[i].detectionsInFrame[j].left) / 2;
//			videoDetections[i].detectionsInFrame[j].center.y = (videoDetections[i].detectionsInFrame[j].bot - videoDetections[i].detectionsInFrame[j].top)/ 2;
//		}
//	}
//}

void settingIDToAnyDetect() {
	bool allreadyDetected;
	int localId;

	for (int i = 1; i < numberOfFrames; i++) {
		allreadyDetected = false;
		for (int j = 0; j < videoDetections[i].numberOfDetection; j++) {
			if (i != 1) {
				for (int k = 0; k < videoDetections[i - 1].numberOfDetection; k++) {
					if (((videoDetections[i].detectionsInFrame[j].center.x <= (videoDetections[i - 1].detectionsInFrame[k].center.x + (frame.cols * 0.01))) && (videoDetections[i].detectionsInFrame[j].center.x >= (videoDetections[i - 1].detectionsInFrame[k].center.x - (frame.cols * 0.01))))
						&& ((videoDetections[i].detectionsInFrame[j].center.y <= (videoDetections[i - 1].detectionsInFrame[k].center.y + (frame.rows * 0.01))) && (videoDetections[i].detectionsInFrame[j].center.y >= (videoDetections[i - 1].detectionsInFrame[k].center.y - (frame.rows * 0.01)))))
					{
						localId = videoDetections[i - 1].detectionsInFrame[k].id;
						allreadyDetected = true;
					}
				}
			}
			else {
				allreadyDetected = false;
			}
			if (!allreadyDetected)
			{
				localId = detectionId;
				detectionId++;
			}
			videoDetections[i].detectionsInFrame[j].id = localId;
		}
	}
}


void readFromFile(string name) {
	string line;
	detection* tempArray;
	detection temp;
	int numberOfDetections;
	ifstream file(name);
	if (file.is_open())
	{
		file >> numberOfFrames;
		getline(file, line);
		videoDetections = new frameDetec[numberOfFrames + 1];
		for (int i = 1; i < numberOfFrames; i++) {
			file >> numberOfDetections;
			videoDetections[i].detectionsInFrame = new detection[numberOfDetections + 1];
			videoDetections[i].numberOfDetection = numberOfDetections;
			for (int j = 0; j < numberOfDetections; j++) {
				file >> videoDetections[i].detectionsInFrame[j].name;
				file.get();
				file >> videoDetections[i].detectionsInFrame[j].left;
				file.get();//space
				file >> videoDetections[i].detectionsInFrame[j].right;
				file.get();//space
				file >> videoDetections[i].detectionsInFrame[j].top;
				file.get();//space
				file >> videoDetections[i].detectionsInFrame[j].bot;
				file.get();//space
				file >> videoDetections[i].detectionsInFrame[j].center.x;
				file.get();//space
				file >> videoDetections[i].detectionsInFrame[j].center.y;
				//file.get();//space
			}
		}
	}
	file.close();
//	settingIDToAnyDetect();
//	setTheCenterOfDetection();
}



/**
* @function main
*/
int main(int argc, char* argv[])
{
	readFromFile("detections.txt");
	//check for the input parameter correctness
	if (argc != 2) {
		cerr << "Incorret input list" << endl;
		cerr << "exiting..." << endl;
		return EXIT_FAILURE;
	}
	//create GUI windows
	namedWindow("Frame", WINDOW_NORMAL);
//	namedWindow("FG Mask MOG 2");

						  //create Background Subtractor objects
	pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach

//	if (strcmp(argv[1], "-vid") == 0) {
		//input data coming from a video
	processVideo(argv[1]);
//	}
	//else if (strcmp(argv[1], "-img") == 0) {
	//	//input data coming from a sequence of images
	//	processImages(argv[2]);
	//}
	//else {
	//	//error in reading input parameters
	//	cerr << "Please, check the input parameters." << endl;
	//	cerr << "Exiting..." << endl;
	//	return EXIT_FAILURE;
	//}
	//destroy GUI windows
	destroyAllWindows();
	return EXIT_SUCCESS;
}

/**
* @function processVideo
*/
void processVideo(char* videoFilename) {
	bool detectedId = false;
	////////////////////////////////////////////////////////////////
	smallImage = imread(imageName, CV_LOAD_IMAGE_UNCHANGED);
//	imshow("original", smallImage);
	Mat imageCopy;
	resize(smallImage, imageCopy, Size(200, 200), 0, 0, INTER_LINEAR);
//	imshow("copy", imageCopy);
	imageCopy.copyTo(smallImage(cv::Rect(240, 24, imageCopy.cols, imageCopy.rows)));
//	imshow("original", smallImage);
	/////////////////////////////////////////////////////////////////////
	//create the capture object
	VideoCapture capture(videoFilename);
	if (!capture.isOpened()) {
		//error in opening the video input
		cerr << "Unable to open video file: " << videoFilename << endl;
		exit(EXIT_FAILURE);
	}
	//read input data. ESC or 'q' for quitting
	while ((char)keyboard != 'q' && (char)keyboard != 27) {
		//read the current frame
		if (!capture.read(frame)) {
			cerr << "Unable to read next frame." << endl;
			cerr << "frame number was : " << frameNumberString << endl;
			cerr << "Exiting..." << endl;
			exit(EXIT_FAILURE);
		}
		if (!detectedId)
		{
			settingIDToAnyDetect();
			detectedId = true;
		}
		//update the background model
		pMOG2->apply(frame, fgMaskMOG2);
		//get the frame number and write it on the current frame
		stringstream ss;
		rectangle(frame, cv::Point(10, 2), cv::Point(100, 20),
			cv::Scalar(255, 255, 255), -1);
		ss << capture.get(CAP_PROP_POS_FRAMES);
		frameNumberString = ss.str();
	//	putText(frame, frameNumberString.c_str(), cv::Point(15, 15),		// write the frame number.
	//		FONT_HERSHEY_SIMPLEX,4, cv::Scalar(0, 0, 0));
		frameNumberInt = stoi(frameNumberString);
	//	for (int i = 0; i < videoDetections[frameNumberInt].numberOfDetection; i++) {		// write the object id for each object.
	//		putText(frame, to_string(videoDetections[frameNumberInt].detectionsInFrame[i].id), cv::Point(videoDetections[frameNumberInt].detectionsInFrame[i].left, videoDetections[frameNumberInt].detectionsInFrame[i].top),
	//			FONT_HERSHEY_SIMPLEX,4, cv::Scalar(200, 0, 0));
	////		keyboard = waitKey(1000);
	//	}
		char* userScore = (char*)malloc(sizeof(char) * 15);
		std::string s = std::to_string(intScore);
		char const *pchar = s.c_str();
		strcpy(userScore, score);
		strcat(userScore, pchar);
		putText(frame, userScore, cv::Point(frame.cols - frame.cols/4, frame.rows - frame.rows/10),			// write the score.
			FONT_HERSHEY_SIMPLEX, 3, cv::Scalar(200, 0, 0),3);
		if (frameNumberInt > 0) {
			for (int i = 0; i < videoDetections[frameNumberInt].numberOfDetection; i++) {
				for (int j = 0; j < videoDetections[frameNumberInt - 1].numberOfDetection; j++) 
				{
					if (videoDetections[frameNumberInt].detectionsInFrame[i].id == videoDetections[frameNumberInt-1].detectionsInFrame[j].id
						&& videoDetections[frameNumberInt-1].detectionsInFrame[j].clicked == true)
					{
						int width = frame.rows * .006;
						CvScalar color(0, 250, 255);
						Point pt1, pt2;
						pt1.x = videoDetections[frameNumberInt].detectionsInFrame[i].left;
						pt1.y = videoDetections[frameNumberInt].detectionsInFrame[i].top;
						pt2.x = videoDetections[frameNumberInt].detectionsInFrame[i].right;
						pt2.y = videoDetections[frameNumberInt].detectionsInFrame[i].bot;
						videoDetections[frameNumberInt].detectionsInFrame[i].clicked = true;
						rectangle(frame, pt1, pt2, color, width, 0);				// print a square if the object has allready detected.
					}
				}
			}
		}
		imageCopy.copyTo(frame(cv::Rect(frame.cols/2,24, imageCopy.cols, imageCopy.rows)));

	//show the current frame and the fg masks
		imshow("Frame", frame);
		//	imshow("FG Mask MOG 2", fgMaskMOG2);
		setMouseCallback("Frame", CallBackFunc, NULL);
		//get the input from the keyboard
		keyboard = waitKey(30);
	}
	//delete capture object
	capture.release();
}

/**
* @function processImages
*/
void processImages(char* fistFrameFilename) {
	//read the first file of the sequence
	frame = imread(fistFrameFilename);
	if (frame.empty()) {
		//error in opening the first image
		cerr << "Unable to open first image frame: " << fistFrameFilename << endl;
		exit(EXIT_FAILURE);
	}
	//current image filename
	string fn(fistFrameFilename);
	//read input data. ESC or 'q' for quitting
	while ((char)keyboard != 'q' && (char)keyboard != 27) {
		//update the background model
		pMOG2->apply(frame, fgMaskMOG2);
		//get the frame number and write it on the current frame
		size_t index = fn.find_last_of("/");
		if (index == string::npos) {
			index = fn.find_last_of("\\");
		}
		size_t index2 = fn.find_last_of(".");
		string prefix = fn.substr(0, index + 1);
		string suffix = fn.substr(index2);
		frameNumberString = fn.substr(index + 1, index2 - index - 1);
		istringstream iss(frameNumberString);
		int frameNumber = 0;
		iss >> frameNumber;
		rectangle(frame, cv::Point(10, 2), cv::Point(100, 20),
			cv::Scalar(255, 255, 255), -1);
		putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
			FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));
		//show the current frame and the fg masks
		imshow("Frame", frame);
		setMouseCallback("Frame", CallBackFunc, NULL);
		//  	imshow("FG Mask MOG 2", fgMaskMOG2);
		//get the input from the keyboard
		keyboard = waitKey(30);
		//search for the next image in the sequence
		ostringstream oss;
		oss << (frameNumber + 1);
		string nextFrameNumberString = oss.str();
		string nextFrameFilename = prefix + nextFrameNumberString + suffix;
		//read the next frame
		frame = imread(nextFrameFilename);
		if (frame.empty()) {
			//error in opening the next image in the sequence
			cerr << "Unable to open image frame: " << nextFrameFilename << endl;
			exit(EXIT_FAILURE);
		}
		//update the path of the current frame
		fn.assign(nextFrameFilename);
	}
}

void CallBackFunc(int event, int x, int y, int flags, void* userdata)
{
	int objectNumber;
	bool addScore = false;
	bool clicked = false;
	if (event == EVENT_LBUTTONDOWN)
	{
		for (int j = 0; j < videoDetections[frameNumberInt].numberOfDetection; j++) {
			if (videoDetections[frameNumberInt].detectionsInFrame[j].left < x && x < videoDetections[frameNumberInt].detectionsInFrame[j].right 
				&& videoDetections[frameNumberInt].detectionsInFrame[j].bot > y && y > videoDetections[frameNumberInt].detectionsInFrame[j].top
				&& (strcmp(imageName, videoDetections[frameNumberInt].detectionsInFrame[j].name) == 0))
			{
				cout << "the object is " << videoDetections[frameNumberInt].detectionsInFrame[j].name << endl;
				videoDetections[frameNumberInt].detectionsInFrame[j].clicked = true;
				objectNumber = j;
				clicked = true;
			}
		}
		if (clicked) {
			for (int i = 0; i < videoDetections[frameNumberInt - 1].numberOfDetection; i++) {
				if (videoDetections[frameNumberInt].detectionsInFrame[objectNumber].id == videoDetections[frameNumberInt - 1].detectionsInFrame[i].id)
				{
					if (videoDetections[frameNumberInt - 1].detectionsInFrame[i].clicked == false) {
						addScore = true;
					}
				}
			}
			if (addScore == true) {
				intScore += 10;
			}
			else {
				if (intScore >= 5) {
					intScore -= 5;
				}
			}
		}
		else {
			if (intScore >= 5) {
				intScore -= 5;
			}
		}
	}
}

